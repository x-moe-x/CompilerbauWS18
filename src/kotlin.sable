Package kotlin;

Helpers
	tab					= 0x09;
	lf					= 0x0a;
	sp					= ' ';
	cr					= 0x0d;

	line_terminator		= lf | cr | cr lf;

	letter				=	[['a' .. 'z']+['A'..'Z']];
	non_zero_digit		=	['1' .. '9'];
	digit				=	'0' | non_zero_digit;

	java_letter			=	letter | '$' | '_';
	java_letter_or_digit =	letter | digit | '$' | '_';

Tokens
	// keywords
	kw_fun				= 'fun';
	kw_while			= 'while';
	kw_if				= 'if';
	kw_else				= 'else';
	kw_var				= 'var';
	kw_int				= 'Int';
	kw_bool				= 'Boolean';

	// pseudo keywords
	pkw_println			= 'println';
	pkw_main			= 'main';
	pkw_args			= 'args';
	pkw_array			= 'Array';
	pkw_string			= 'String';

	integer				=	'0'
						|	non_zero_digit digit*
						;

	boolean				=	'true'
	 					|	'false'
						;

	identifier			=	java_letter java_letter_or_digit*;


	not					= '!';
	plus				= '+';
	minus				= '-';
	star				= '*';
	slash				= '/';
	percent				= '%';
	leq					= '<=';
	geq					= '>=';
	lt					= '<';
	gt					= '>';
	equals				= '==';
	not_equals			= '!=';
	ampamp				= '&&';
	oror				= '||';
	l_par				= '(';
	r_par				= ')';
	l_brc				= '{';
	r_brc				= '}';
	semi				= ';';
	assign				= '=';
	colon				= ':';

	white_space = (sp | tab | line_terminator)*;

Ignored Tokens
	white_space;

Productions

	function					=	kw_fun pkw_main l_par pkw_args colon pkw_array lt pkw_string gt r_par l_brc declaration* stmt* r_brc
										{-> New function([declaration.stmt],[stmt])}
								;

	declaration {-> stmt}		=	{int} kw_var identifier colon kw_int assign expr semi
											{-> New stmt.declaration(identifier, New type.int(), expr)}
								|	{bool} kw_var identifier colon kw_bool assign expr semi
											{-> New stmt.declaration(identifier, New type.bool(), expr)}
								;

	stmt						=	{matched} matched {-> matched.stmt}
								|	{open} open {-> open.stmt}
								;

	open {-> stmt}				=	{if} kw_if l_par expr r_par stmt {-> New stmt.if(expr, [stmt], [])}
								|	{if_else} kw_if l_par expr r_par matched kw_else open {-> New stmt.if(expr, [matched.stmt], [open.stmt])}
								;

	matched {-> stmt}			=	{if_else} kw_if l_par expr r_par [true_block]:matched kw_else [false_block]:matched {-> New stmt.if(expr, [true_block.stmt], [false_block.stmt])}
									// other:
								|	{loop} while {-> while.stmt}
								|	{print} print {-> print.stmt}
								|	{assing} assignment {-> assignment.stmt}
								|	{block} block {-> New stmt.block([block.stmt])}
								;

	assignment {-> stmt}		=	identifier assign expr semi {-> New stmt.assign(identifier, expr)}
								;

	print {-> stmt}				=	pkw_println l_par expr r_par semi {-> New stmt.print(expr)}
								;

	while {-> stmt}				=	kw_while l_par expr r_par block {-> New stmt.while(expr, [block.stmt])}
								;

	block {-> stmt*}			=	l_brc stmt* r_brc {-> [stmt] }
								;

	expr						=	or {-> or.expr}
								;

	or {-> expr}				=	{and} and {-> and.expr}
								|	{or} or oror and {-> New expr.binary(or.expr, New binop.or(), and.expr)}
								;

	and {-> expr}				=	{eq} eq {-> eq.expr}
								|	{and} and ampamp eq {-> New expr.binary(and.expr, New binop.and(), eq.expr)}
								;

	eq {-> expr}					=	{rel} rel {-> rel.expr}
								|	{eq} eq equals rel {-> New expr.binary(P.eq.expr, New binop.equals(), rel.expr)}
								|	{neq} eq not_equals rel {-> New expr.binary(P.eq.expr, New binop.not_equals(), rel.expr)}
								;

	rel {-> expr}				=	{add} add {-> add.expr}
								|	{lt} rel lt add {-> New expr.binary(rel.expr, New binop.lt(), add.expr)}
								|	{gt} rel gt add {-> New expr.binary(rel.expr, New binop.gt(), add.expr)}
								|	{leq} rel leq add {-> New expr.binary(rel.expr, New binop.leq(), add.expr)}
								|	{geq} rel geq add {-> New expr.binary(rel.expr, New binop.geq(), add.expr)}
								;

	add {-> expr}				=	{mult} mult {-> mult.expr}
								|	{plus} add plus mult {-> New expr.binary(add.expr, New binop.plus(), mult.expr)}
								|	{minus} add minus mult {-> New expr.binary(add.expr, New binop.minus(), mult.expr)}
								;

	mult {-> expr}				=	{unary} unary {-> unary.expr}
								|	{mult} mult star unary {-> New expr.binary(mult.expr, New binop.mul(), unary.expr)}
								|	{div} mult slash unary {-> New expr.binary(mult.expr, New binop.div(), unary.expr)}
								|	{mod} mult percent unary {-> New expr.binary(mult.expr, New binop.mod(), unary.expr)}
								;

	unary {-> expr}				=	{atomic} atomic {-> atomic.expr}
								|	{not} not unary {-> New expr.unary(New unop.not(), unary.expr)}
								|	{plus} plus unary {-> New expr.unary(New unop.plus(), unary.expr)}
								|	{minus} minus unary {-> New expr.unary(New unop.minus(), unary.expr)}
								;

	atomic {-> expr}			=	{id} identifier {-> New expr.variable(identifier)}
								|	{lit} constant {-> constant.expr}
								;

	constant {-> expr}			=	{int} integer {-> New expr.integer_literal(integer)}
								|	{bool} boolean {-> New expr.boolean_literal(boolean)}
								;

Abstract Syntax Tree

	function	=	[declarations]:stmt* [statements]:stmt*
				;

	stmt		=	{while} [condition]:expr [statements]:stmt*
				|	{print} [message]:expr
				|	{assign} [var]:identifier [expr]:expr
				|	{if} [condition]:expr [true_statements]:stmt* [false_statements]:stmt*
				|	{block} [statements]:stmt*
				|	{declaration} [var]:identifier [type]:type [expr]:expr
				;

	expr		=	{variable} identifier
  				|	{integer_literal} integer
		  		|	{boolean_literal} boolean
		  		|	{unary} [op]:unop [r]:expr
		  		|	{binary} [l]:expr [op]:binop [r]:expr
		  		;

	type		=	{int}
				|	{bool}
				;

	unop		=	{not}
				|	{plus}
				|	{minus}
				;

	binop		=	{mul}
				|	{div}
				|	{mod}
				|	{plus}
				|	{minus}
				|	{lt}
				|	{gt}
				|	{leq}
				|	{geq}
				|	{equals}
				|	{not_equals}
				|	{and}
				|	{or}
				;
